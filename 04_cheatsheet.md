# Конспект: как работает система и почему

---

## Что делает система

Подключается к 4 биржам (Binance, Bybit, MEXC, OKX), получает цены в реальном времени по ~682 торговым парам, сравнивает цены spot одной биржи с futures другой по 12 направлениям, при обнаружении спреда выше порога — отслеживает его движение каждые 200 мс в течение 3 часов и пишет в файл. Если спред сошёлся раньше — трекинг закрывается и пара сразу доступна для нового сигнала.

---

## Pair Discovery: откуда берутся списки пар

Раньше списки пар задавались вручную в текстовых файлах. Проблема: биржи постоянно добавляют и удаляют пары, а некоторые пары числятся в REST API но реально не отдают данные по WebSocket.

Теперь это автоматизировано. Модуль Pair Discovery запускается перед основной системой и делает 5 шагов:

**Шаг 1 — сбор.** REST-запросы к 8 endpoints (4 биржи × spot + futures). Получаем все торговые пары с каждого рынка: имя, base/quote валюту, статус, минимальный объём.

**Шаг 2 — нормализация.** На Binance пара называется «BTCUSDT», на OKX — «BTC-USDT», на OKX futures — «BTC-USDT-SWAP», на MEXC futures — «BTC_USDT». Discovery приводит все к единому формату «BTC-USDT» и присваивает глобальный числовой symbol_id. Один и тот же BTC-USDT на всех биржах = один symbol_id.

**Шаг 3 — пересечение.** Для каждого из 12 направлений (например, «OKX spot → MEXC futures») берём пересечение: пары, которые есть И на OKX spot И на MEXC futures. Результат: ~272 пары для этого направления.

**Шаг 4 — WS-валидация.** Подключаемся к WebSocket всех 8 источников, подписываемся на все пары и ждём 30 секунд. Пары, от которых не пришло ни одного обновления — помечаются как invalid и удаляются из всех списков. Типичные причины: пара приостановлена, нулевая ликвидность, существует в REST но не в WS.

**Шаг 5 — генерация конфигов.** Записываются бинарные файлы (symbols.bin, directions.bin) которые загружаются feeds, engine и tracker при старте. Плюс human-readable отчёты для проверки.

Весь процесс занимает ~60 секунд. Запускается один раз при старте системы и по cron каждые 6–12 часов для обнаружения новых пар и делистингов.

---

## Почему всё на числовых ID

На hot path (200K сообщений/сек) каждая наносекунда имеет значение. Сравнение строк «okx_spot_mexc_futures» — это 20–50 нс, HashMap lookup по строке — 30–50 нс. Сравнение числа `direction_id == 3` — 1 нс, доступ к массиву по индексу — 1 нс.

Три числа однозначно определяют любое событие: `source_id` (u8, 0..7), `symbol_id` (u16, 0..N), `direction_id` (u8, 0..11). Строковые имена нужны только при загрузке конфигов (Discovery) и при записи в текстовый файл (Tracker). Обе операции вне hot path.

---

## Почему Rust, а не Python

Требование — обработать сигнал за 50 мс. Python с GIL и garbage collector может в любой момент «заморозить» программу на 1–10 мс. Rust — нет GC, предсказуемая латентность. Hot path занимает ~15 μs, запас 3000×.

---

## Почему 11 отдельных процессов

Crash одного не убивает остальные. systemd перезапускает упавший за 1 секунду. Для будущего торгового бота это критично: если Order Manager упал при открытой позиции — feeds и engine продолжают работать, supervisor запускает recovery.

---

## Shared memory: как процессы общаются

Участок физической RAM, отображённый в адресное пространство нескольких процессов. Feed пишет цену по адресу X, engine читает с того же адреса X — один физический байт, без копирования, без системных вызовов. ~50–200 нс вместо 3–30 μs у сокетов.

В shared memory хранятся: Price Store (цены), Bitmap (что обновилось), Event Bus (сигналы), Health Table (heartbeats), Control Flags (pause/kill).

---

## Cache lines, false sharing, SeqLock

**Cache line** — процессор кеширует данные блоками по 64 байта. **False sharing** — два независимых поля в одном блоке: запись одного инвалидирует кеш для другого. Решение: каждый PriceEntry = ровно 64 байта с выравниванием `align(64)`. False sharing устранён полностью.

**Кэш-пинг-понг** — неизбежная передача cache line между ядрами writer → reader. Минимизируется: split seq/data (engine проверяет только seq, 5 нс, в 90% случаев data не трогается), CPU pinning (фиксированные ядра = предсказуемый путь), local cache в engine.

**SeqLock** — lock-free механизм для 1 writer + N readers. Writer увеличивает счётчик (нечётный = «пишу»), пишет данные, увеличивает снова (чётный = «готово»). Reader проверяет счётчик до и после чтения. Если совпал — данные валидны. ~5–10 нс на операцию, writer никогда не блокируется.

---

## Как Engine находит спред

При обновлении цены (например, OKX Spot, BTC-USDT):
1. Lookup `SourceSymbolIndex[source=6][symbol=0]` → 3 записи: direction 0 (→MEXC fut), direction 1 (→Bybit fut), direction 2 (→Binance fut). Это flat array, 1–2 нс.
2. Для каждой: cached read цены контрпартии из Price Store. 5 нс если не изменилась (90%+), 15–40 нс если изменилась.
3. Spread = (fut_bid - spot_ask) / spot_ask × 100%. Если > порога → сигнал в Event Bus.

---

## Tracker: 200 мс + converge + re-signal

Каждые 200 мс Tracker читает цены для всех активных трекингов и пишет снэпшот. Три исхода: EXPIRED (3 часа прошло), CONVERGED (спред < порога → пара **немедленно** доступна для нового сигнала), TRACK (обычный снэпшот).

---

## Логирование

Hot path (200K/sec): никаких логов. Атомарные счётчики, ~1 нс. Тёплый путь (tracker): data file через BufWriter. Редкие события: non-blocking tracing appender.

---

## CPU pinning на i9-13900

8 feeds → E-cores 16–23 (I/O bound, достаточно). Engine → P-core 0, SCHED_FIFO (CPU bound, нужна скорость). Tracker → E-core 24 (просыпается каждые 200 мс). Discovery → не pinned (работает 60 сек при старте).

---

## Что заложено на будущее

1. **Event envelope с correlation_id** — связь сигнал→ордер→позиция.
2. **Health Table** — supervisor видит зависшие процессы.
3. **Control Flags** — kill-switch через shared memory.
4. **Crash recovery** — Tracker восстанавливает состояние; прототип WAL.
5. **Discovery сохраняет min_qty/tick_size** — Order Manager использует для расчёта размеров ордеров.
6. **MAX_SYMBOLS=1024** — shm не нужно пересоздавать при добавлении пар.

---

## Числа

| Что | Число |
|-----|-------|
| Уникальных пар | ~682 (динамически) |
| Источников | 8 |
| WS-соединений | ~20 |
| Направлений | 12 (~3590 пар-направлений) |
| Price updates/sec | ~200K пиково |
| Hot path латентность | ~15 μs |
| Price Store | 682 KB (seqs+data) |
| RAM всего | ~60 MB |
| CPU | < 5% |
| Discovery время | ~60 сек |
| Процессов | 11 (discovery + 8 feeds + engine + tracker) |
| Базовая разработка | 20–35 дней |

---

## Startup sequence

```
shm-init → pair-discovery → [feeds + engine + tracker параллельно]
```

---

## Карта документов

```
01_architecture.md         — ЧТО строим (база + будущее)
02_implementation_order.md — В КАКОМ ПОРЯДКЕ строим
03_technical_specs.md      — КАК ИМЕННО (ТЗ для каждого файла)
04_cheatsheet.md           — ПОЧЕМУ так (этот документ)
```
